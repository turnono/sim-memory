---
description: 
globs: 
alwaysApply: false
---
# Google ADK Development Patterns

## Core ADK Documentation
Always reference the official documentation for the most up-to-date patterns:
- **Main Docs**: [Google ADK Documentation](mdc:https:/google.github.io/adk-docs)
- **Tutorial**: [ADK Tutorial](mdc:https:/google.github.io/adk-docs/get-started/tutorial)
- **Agent Guide**: [ADK Agents](mdc:https:/google.github.io/adk-docs/get-started/about)

## Essential ADK Imports
```python
from google.adk import Agent
from google.adk.tools import FunctionTool
from google.adk.tools.agent_tool import AgentTool
```

## Agent Creation Patterns

### 1. Basic Agent Structure
```python
agent = Agent(
    name="agent_name",              # Unique identifier
    model="gemini-2.0-flash",       # Model specification
    description="Brief description", # Used for auto-delegation
    instruction="Detailed instructions...",
    tools=[],                       # List of tools
)
```

### 2. Multi-Agent System with Sub-Agents
ADK supports automatic delegation using the `sub_agents` parameter:
```python
root_agent = Agent(
    name="root_agent",
    model="gemini-2.0-flash", 
    instruction="I can delegate to specialized agents...",
    sub_agents=[greeting_agent, farewell_agent],  # Auto-delegation
    tools=[FunctionTool(func=my_tool)]
)
```

### 3. Agent as Tool Pattern
For explicit control, use agents as tools:
```python
root_agent = Agent(
    name="root",
    tools=[
        AgentTool(agent=memory_agent),
        AgentTool(agent=web_search_agent),
        FunctionTool(func=custom_tool)
    ]
)
```

## Tool Development Patterns

### 1. Function Tool Creation
```python
async def my_tool(param: str, tool_context=None) -> str:
    """
    Tool description that ADK uses for documentation.
    
    Args:
        param: Description of parameter
        tool_context: ADK ToolContext for session access
        
    Returns:
        Description of return value
    """
    try:
        # Tool implementation
        return result
    except Exception as e:
        logger.error(f"Tool failed: {e}")
        return f"Tool temporarily unavailable: {str(e)}"

# Register the tool
tool = FunctionTool(func=my_tool)
```

### 2. Tool Context Usage
```python
async def context_aware_tool(query: str, tool_context=None) -> str:
    """Tool that uses session context."""
    # Access user ID from session
    user_id = "default_user"
    if (tool_context and 
        hasattr(tool_context, "session") and 
        hasattr(tool_context.session, "user_id")):
        user_id = tool_context.session.user_id
    
    # Use user_id for personalized responses
    return f"Response for user: {user_id}"
```

## Common ADK Patterns

### 1. Agent Invocation
```python
# CORRECT: Use invoke() method
response = await agent.invoke("User message")

# INCORRECT: Don't use generate() - it doesn't exist
# response = await agent.generate("message")  # This will fail
```

### 2. Error Handling
```python
async def robust_agent_call(agent, message):
    """Robust agent invocation with error handling."""
    try:
        response = await agent.invoke(message)
        return response
    except Exception as e:
        logger.error(f"Agent invocation failed: {e}")
        return "Agent temporarily unavailable"
```

### 3. Model Configuration
```python
# Use supported models
agent = Agent(
    model="gemini-2.0-flash",      # Recommended for most cases
    # model="gemini-2.0-flash-exp", # Experimental features
    # model="gemini-1.5-pro",       # Alternative option
)
```

## ADK Architecture Principles

### 1. Agent Delegation
ADK supports two delegation patterns:

**Automatic Delegation** (using `sub_agents`):
- ADK automatically decides which sub-agent to use
- Based on agent `description` and user query
- LLM makes delegation decisions

**Explicit Delegation** (using `AgentTool`):
- Root agent explicitly chooses when to use sub-agents
- More control over agent selection
- Used in this project: [sim_guide/agent.py](mdc:sim_guide/agent.py)

### 2. Tool Organization
```python
# Group related tools
preference_tools = [
    FunctionTool(func=get_user_preferences),
    FunctionTool(func=set_user_preference),
]

business_tools = [
    FunctionTool(func=get_business_advice),
    FunctionTool(func=analyze_opportunity),
]

# Combine for agent
all_tools = preference_tools + business_tools
```

### 3. Session and State Management
ADK handles conversation context automatically:
- **Session**: Single conversation instance
- **State**: Agent's working memory for that session
- **Events**: History of conversation turns

## Best Practices for This Project

### 1. Context-Passing Architecture
Instead of giving sub-agents direct memory access:
```python
# GOOD: Pass curated context
async def consult_specialist(context: str, query: str) -> str:
    formatted_context = f"""
    Context: {context}
    Query: {query}
    Instructions: Provide specialized advice...
    """
    return await specialist_agent.invoke(formatted_context)

# AVOID: Direct memory access in sub-agents
```

### 2. Tool Registration Pattern
Follow the pattern in [sim_guide/tools/__init__.py](mdc:sim_guide/tools/__init__.py):
```python
from google.adk.tools import FunctionTool
from .module import function1, function2

# Create tool instances
tools = [
    FunctionTool(func=function1),
    FunctionTool(func=function2),
]

# Export for agent use
ALL_TOOLS = tools
```

### 3. Agent Description for Delegation
Write clear descriptions for automatic delegation:
```python
agent = Agent(
    name="marketing_specialist",
    description="Handles marketing strategy, customer acquisition, and brand positioning",
    instruction="You are a marketing expert..."
)
```

## Troubleshooting Common Issues

### 1. Agent Invocation Errors
```python
# Problem: 'LlmAgent' object has no attribute 'invoke'
# Solution: Check ADK version and import structure

# Verify correct import
from google.adk import Agent

# Ensure proper agent creation
agent = Agent(name="test", model="gemini-2.0-flash", instruction="...")
```

### 2. Tool Registration Issues
```python
# Problem: Tools not appearing in agent
# Solution: Ensure proper FunctionTool wrapping

from google.adk.tools import FunctionTool

# Correct tool registration
tools = [FunctionTool(func=my_function)]

agent = Agent(
    name="agent",
    tools=tools  # Pass the FunctionTool instances
)
```

### 3. Model Configuration
```python
# Use supported models
SUPPORTED_MODELS = [
    "gemini-2.0-flash",
    "gemini-2.0-flash-exp", 
    "gemini-1.5-pro"
]
```

## Memory and Context Management

### 1. Session Context
```python
async def session_aware_function(tool_context=None):
    """Access session information in tools."""
    if tool_context and hasattr(tool_context, 'session'):
        session_id = tool_context.session.session_id
        user_id = tool_context.session.user_id
        # Use session information
```

### 2. Memory Integration
For memory operations, use the hybrid system in [sim_guide/services/rag_memory_service.py](mdc:sim_guide/services/rag_memory_service.py):
```python
# Cost-optimized memory search
result = await search_memories_hybrid(user_id, query)

# Force semantic search when needed
result = await search_memories_hybrid(user_id, query, force_semantic=True)
```

## Testing ADK Agents

### 1. Basic Agent Testing
```python
async def test_agent():
    """Test agent invocation."""
    response = await agent.invoke("Test message")
    assert response is not None
    assert len(response) > 0
```

### 2. Tool Testing
```python
async def test_tool():
    """Test tool functionality."""
    result = await my_tool("test_param")
    assert "expected_content" in result
```

Remember: ADK is actively developed, so always check the latest documentation for new features and patterns.
