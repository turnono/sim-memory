---
description:
globs:
alwaysApply: false
---
# Sim-Memory Life Guidance System Architecture

## Project Overview
This is a life guidance AI system built with **Google ADK** (Agent Development Kit) that provides personalized AI assistance through a sophisticated multi-agent architecture with hybrid memory optimization.

## Core Architecture Principles

### 1. Google ADK Framework
- **Primary Documentation**: Always reference [Google ADK Documentation](https://google.github.io/adk-docs/)
- **Agent Creation**: Use `Agent()` from `google.adk` with proper model configuration
- **Tools**: Use `FunctionTool` for function-based tools and `AgentTool` for sub-agents
- **Sub-Agent Pattern**: Agents can have `sub_agents` parameter for automatic delegation
- **Invocation**: Use `agent.invoke(message)` not `.generate()` for agent calls

### 2. Hierarchical Sub-Agent System
The system uses a **context-passing architecture** where sub-agents receive curated context rather than direct memory access:

#### Main Agent Structure
- **Root Agent**: [sim_guide/agent.py](mdc:sim_guide/agent.py) - Main orchestrator with memory access
- **Memory Agent**: [sim_guide/sub_agents/memory_agent.py](mdc:sim_guide/sub_agents/memory_agent.py) - Handles all memory operations
- **Business Strategist**: [sim_guide/sub_agents/business_strategist_agent.py](mdc:sim_guide/sub_agents/business_strategist_agent.py) - MBA-level business guidance

#### Business Strategist Hierarchy
The Business Strategist demonstrates the hierarchical pattern:
```
Business Strategist (Main)
├── Marketing Strategist
├── Finance Strategist  
├── Operations Strategist
├── Product Strategist
└── Growth Strategist
```

**Key Principle**: Each level receives context from its parent, no direct memory access.

### 3. Memory System Architecture
The hybrid memory system optimizes costs by intelligently routing between keyword search and semantic RAG:

#### Core Memory Service
- **Main Service**: [sim_guide/services/rag_memory_service.py](mdc:sim_guide/services/rag_memory_service.py)
- **Hybrid Function**: `search_memories_hybrid()` - Automatically chooses search method
- **Classification**: `classify_query_complexity()` - Determines if keyword or semantic search
- **Cost Optimization**: Uses keyword search for simple queries, semantic for complex ones

#### Memory Integration
- **Memory Agent**: [sim_guide/sub_agents/memory_agent.py](mdc:sim_guide/sub_agents/memory_agent.py) provides memory tools
- **Tools**: [sim_guide/tools/memory.py](mdc:sim_guide/tools/memory.py) for memory operations
- **Session Management**: [sim_guide/tools/session.py](mdc:sim_guide/tools/session.py) for conversation context

### 4. Tools Architecture
Tools are organized by domain and follow ADK patterns:

#### Tool Structure
- **Preferences**: [sim_guide/tools/preferences.py](mdc:sim_guide/tools/preferences.py) - User preference management
- **Business Strategy**: [sim_guide/tools/business_strategy.py](mdc:sim_guide/tools/business_strategy.py) - Business consultation tools
- **Tools Registry**: [sim_guide/tools/__init__.py](mdc:sim_guide/tools/__init__.py) - Central tool registration

#### Tool Pattern
```python
from google.adk.tools import FunctionTool

async def my_tool_function(param: str, tool_context=None) -> str:
    """Tool description for ADK."""
    # Implementation
    return result

# Register as FunctionTool
tool = FunctionTool(func=my_tool_function)
```

## Development Guidelines

### 1. Creating New Sub-Agents
When creating new sub-agents, follow the established patterns:

1. **Context-Passing**: No direct memory access, receive context from parent
2. **Agent Definition**: Use proper ADK `Agent()` constructor
3. **Tool Integration**: Provide tools via `FunctionTool`
4. **Hierarchy**: Can have their own sub-agents for specialization

Example from [sim_guide/sub_agents/business_strategist_agent.py](mdc:sim_guide/sub_agents/business_strategist_agent.py):
```python
marketing_strategist = Agent(
    name="marketing_strategist",
    model="gemini-2.0-flash",
    description="Specialized marketing strategy expert",
    instruction="""Detailed instruction..."""
)
```

### 2. Memory Operations
Always use the hybrid memory system for cost optimization:

```python
# Use hybrid search (automatically chooses method)
result = await search_memories_hybrid(user_id, query)

# Force semantic search for complex analysis
result = await search_memories_hybrid(user_id, query, force_semantic=True)
```

### 3. Tool Development
Follow the established tool patterns:

1. **Async Functions**: All tools should be async
2. **Type Hints**: Use proper type hints for parameters
3. **Error Handling**: Include try-catch blocks with logging
4. **Documentation**: Provide clear docstrings for ADK
5. **Tool Context**: Accept `tool_context=None` parameter

### 4. Agent Integration
To integrate new agents into the system:

1. **Add to Sub-Agents**: Update [sim_guide/sub_agents/__init__.py](mdc:sim_guide/sub_agents/__init__.py)
2. **Create Tools**: Add corresponding tools in [sim_guide/tools/](mdc:sim_guide/tools/)
3. **Register Tools**: Update [sim_guide/tools/__init__.py](mdc:sim_guide/tools/__init__.py)
4. **Main Agent**: Add to root agent if needed in [sim_guide/agent.py](mdc:sim_guide/agent.py)

## Testing and Validation

### Test Structure
- **Business Strategist Test**: [test_business_strategist.py](mdc:test_business_strategist.py) - Example test pattern
- **Hybrid Memory Test**: [test_hybrid_memory.py](mdc:test_hybrid_memory.py) - Memory system testing

### Test Pattern
```python
async def test_tool_function():
    """Test a specific tool or agent functionality."""
    try:
        result = await tool_function(params)
        # Validate result
        return True
    except Exception as e:
        print(f"Test failed: {e}")
        return False
```

## Key ADK Patterns to Follow

### 1. Agent Creation
```python
from google.adk import Agent
from google.adk.tools import FunctionTool

agent = Agent(
    name="agent_name",
    model="gemini-2.0-flash",
    description="Clear description for delegation",
    instruction="Detailed instructions...",
    tools=[FunctionTool(func=my_function)]
)
```

### 2. Agent Invocation
```python
# Correct way to call agents
response = await agent.invoke("User message or context")

# NOT agent.generate() - this will fail
```

### 3. Tool Integration
```python
from google.adk.tools.agent_tool import AgentTool

# For using agents as tools
root_agent = Agent(
    name="root",
    tools=[
        AgentTool(agent=sub_agent),
        FunctionTool(func=function_tool)
    ]
)
```

## Cost Optimization Principles

1. **Hybrid Memory**: Use keyword search for simple queries, semantic for complex
2. **Lightweight Agents**: Keep sub-agents focused and efficient
3. **Context Curation**: Only pass relevant context to sub-agents
4. **Tool Efficiency**: Design tools to be fast and cost-effective

## File Organization
```
sim_guide/
├── agent.py              # Root agent definition
├── prompts/              # Agent instructions
├── sub_agents/           # All sub-agents
│   ├── memory_agent.py
│   ├── business_strategist_agent.py
│   └── __init__.py
├── tools/                # Function-based tools
│   ├── business_strategy.py
│   ├── preferences.py
│   └── __init__.py
├── services/             # Core services
│   └── rag_memory_service.py
└── callbacks/            # ADK callbacks
```

Remember: Always reference Google ADK documentation for the latest patterns and best practices.
