---
description:
globs:
alwaysApply: false
---
# ADK Agent Architecture Guidelines

## Project Overview
This project builds Taajirah, an AI life guidance system using Google's Agent Development Kit (ADK). The architecture follows a hierarchical agent pattern with clear separation of concerns.

## Core Architecture Principles

### 1. Hierarchical Agent Structure
- **Root Agent**: [sim_guide/agent.py](mdc:sim_guide/agent.py) - Pure coordinator with no direct tools
- **Sub-Agents**: Located in [sim_guide/sub_agents/](mdc:sim_guide/sub_agents/) - Specialized domain experts
- **Tool Delegation**: Root agent delegates to sub-agents, never handles domain logic directly

### 2. Sub-Agent Organization
Each sub-agent follows this standard structure:
```
sim_guide/sub_agents/[agent_name]/
├── __init__.py          # Agent export
├── agent.py             # Agent implementation
├── prompt.py            # DESCRIPTION and INSTRUCTION
├── tools/               # Agent-specific tools
│   ├── __init__.py
│   └── [tool_files].py
└── services/            # Agent-specific business logic
    ├── __init__.py
    └── [service_files].py
```

### 3. Current Sub-Agents
- **user_context_manager**: [sim_guide/sub_agents/user_context_manager/](mdc:sim_guide/sub_agents/user_context_manager/) - Memory, sessions, preferences
- **business_strategist**: [sim_guide/sub_agents/business_strategist/](mdc:sim_guide/sub_agents/business_strategist/) - MBA-level business strategy
- **web_search**: [sim_guide/sub_agents/web_search/](mdc:sim_guide/sub_agents/web_search/) - Web search and research
- **capability_enhancement**: [sim_guide/sub_agents/capability_enhancement/](mdc:sim_guide/sub_agents/capability_enhancement/) - Meta-cognitive improvements

## ADK Implementation Patterns

### Agent Configuration
```python
from google.adk import Agent

agent = Agent(
    name="agent_name",
    model="gemini-2.0-flash",  # Standard model
    instruction=INSTRUCTION,
    description=DESCRIPTION,
    tools=[tool1, tool2, ...],
    # ADK-specific configurations
)
```

### Tool Integration
- Tools belong to specific agents, not shared globally
- Use `@tool` decorator for tool functions
- Tools should be co-located with their agent in `tools/` directory
- Import tools into agent configuration: `from .tools import tool_function`

### Service Pattern
- Business logic goes in `services/` directory
- Services are imported by both tools and agents
- Services handle complex operations, tools are thin wrappers
- Example: [sim_guide/sub_agents/user_context_manager/services/](mdc:sim_guide/sub_agents/user_context_manager/services/)

### Prompt Structure
Each agent has a [prompt.py](mdc:sim_guide/sub_agents/user_context_manager/prompt.py) file with:
```python
DESCRIPTION = "Brief agent description"

INSTRUCTION = """
Detailed instructions for the agent including:
- Role and responsibilities
- Available tools and their usage
- Behavioral guidelines
- Context handling instructions
"""
```

## Memory and Session Management

### Memory Architecture
- ADK memory integration via [sim_guide/sub_agents/user_context_manager/tools/memory.py](mdc:sim_guide/sub_agents/user_context_manager/tools/memory.py)
- RAG memory service: [sim_guide/sub_agents/user_context_manager/services/rag_memory_service.py](mdc:sim_guide/sub_agents/user_context_manager/services/rag_memory_service.py)
- Memory operations: `load_life_guidance_memory`, `preload_life_context`, `load_life_resources`

### Session Management
- Session service: [sim_guide/sub_agents/user_context_manager/services/session_service.py](mdc:sim_guide/sub_agents/user_context_manager/services/session_service.py)
- Session tools: [sim_guide/sub_agents/user_context_manager/tools/session.py](mdc:sim_guide/sub_agents/user_context_manager/tools/session.py)
- Operations: `analyze_session_context`, `get_conversation_continuity_hints`, `update_session_context`

## Import Conventions

### Agent Imports
```python
# Root agent
from sim_guide.agent import root_agent

# Sub-agents
from sim_guide.sub_agents.user_context_manager.agent import user_context_manager
from sim_guide.sub_agents.business_strategist.agent import business_strategist
```

### Tool Imports
```python
# From within sub-agent
from .tools.memory import load_life_guidance_memory
from .tools.preferences import get_user_preferences

# From external modules
from sim_guide.sub_agents.user_context_manager.tools.memory import load_life_guidance_memory
```

### Service Imports
```python
# From within sub-agent
from .services.rag_memory_service import health_check
from .services.user_service import UserPreferences

# From external modules
from sim_guide.sub_agents.user_context_manager.services import UserPreferences
```

## Testing and Evaluation

### Test Structure
- Main tests: [test_refactored_system.py](mdc:test_refactored_system.py)
- Evaluation suite: [evals/](mdc:evals/) directory
- Agent-specific tests: [evals/business_strategist_evals.py](mdc:evals/business_strategist_evals.py)

### Evaluation Patterns
- Use `python -m evals.test_name` for running evaluations
- Each evaluation should test both functionality and integration
- Mock tool contexts for unit testing: `MockToolContext` class

## Configuration Management

### Environment Variables
- Google Cloud configuration via [.env](mdc:.env)
- ADK-specific settings in agent initialization
- Project configuration: `PROJECT_ID`, `LOCATION`, `REASONING_ENGINE_ID`

### Model Configuration
- Standard model: `gemini-2.0-flash`
- Consistent across all agents for uniformity
- Defined in agent initialization

## Best Practices

### 1. Agent Design
- Keep agents focused on single domains
- Root agent should only coordinate, never execute domain logic
- Each agent should have clear, well-defined responsibilities

### 2. Tool Design
- Tools should be thin wrappers around service functions
- Include proper error handling and validation
- Document tool parameters and return values

### 3. Service Design
- Services contain the actual business logic
- Should be testable independently of agents
- Use async/await patterns for ADK compatibility

### 4. Prompt Engineering
- Keep prompts aligned with actual tool capabilities
- Include specific examples of tool usage
- Update prompts when tools change

### 5. File Organization
- Follow the standard sub-agent directory structure
- Co-locate related functionality (tools with agents, services with consumers)
- Maintain clean import hierarchies

## Development Workflow

### Adding New Sub-Agents
1. Create directory: `sim_guide/sub_agents/new_agent/`
2. Implement: `__init__.py`, `agent.py`, `prompt.py`
3. Add tools in `tools/` directory
4. Add services in `services/` directory
5. Register with root agent in [sim_guide/agent.py](mdc:sim_guide/agent.py)
6. Update prompts to reflect new capabilities

### Adding New Tools
1. Implement in appropriate `tools/` directory
2. Import in agent configuration
3. Update agent prompt to mention new tool
4. Add evaluation tests
5. Update documentation

### Modifying Services
1. Update service implementation
2. Update dependent tools
3. Run evaluation suite to ensure compatibility
4. Update any affected prompts or documentation
